\documentclass{article}
%\VignetteIndexEntry{webmaps: Javascript mapping for R}
%\VignettePackage{webmaps}
\usepackage{listings}
\usepackage{Sweave}
\SweaveOpts{keep.source=TRUE}
<<<SweaveListingspreparations, results=tex, echo=FALSE>>=
require(SweaveListingUtils)
SweaveListingPreparations()
@

\title{Web Maps}

\author{Barry Rowlingson}

\begin{document}

\maketitle

\section*{Javascript web mapping}

There is great demand these days for maps on web pages. Providers such as Google and Yahoo!
have mapping systems that allow users to add data onto their base maps for web pages. 

However there are also mapping frameworks written in Javascript that run within web browsers.
They can then fetch map data locally or over the web for display. All that's necessary
to make the map public is to put it on a public web server. This provides a very low
bar to publishing spatial data.

The big map data companies restrict use of their map data. As an alternative, the 
OpenStreetMap project has been sourcing freely usable data and encouraging the 
collection and creation of data by anyone with a GPS or GPS-enabled phone. A very
high quality map database with a wide coverage has been created this way. This
data can be combined with open source javascript mapping tools to create a freely
usable and re-usable map system.

\section*{Spatial data in R}

The \texttt{sp} package contains functions for handling spatial data along the lines
of the Open Geospatial Consortium Simple Features specification. This covers point,
line, and area features (including holes and islands). Each feature can have a 
database-style record of attributes. Spatial data can also have a coordinate
reference system to enable projections and conversions between reference systems.

This package will make use of the \texttt{sp} package objects for spatial data.

\section*{State data}

<<echo=FALSE,results=hide>>=
library(webmaps,lib.loc="../../../pkg.Rcheck")
@ 

For this section we will create a simple map from the USA state locations
and data provided with R. First, we need the \texttt{webmaps} package -- this 
also loads the \texttt{sp} package:

\begin{Scode}
> require(webmaps)
\end{Scode}

Then we make a \texttt{SpatialPointsDataFrame} from the state data:

<<>>=
state=data.frame(state.x77)
state$Name = rownames(state)
coordinates(state) = cbind(state.center$x,state.center$y)
@ 


And now we can make a map
<<>>=
osmMap(list(state=state),title="State Data",outputDir="./states")
@ 

Now open that file in your web browser and you should see a map. You can
click on the points to get the state data:

\includegraphics{us.png}

This map is produced using the OpenLayers mapping toolkit and OpenStreetMap
base layer. At upper-left are the zoom and navigation controls (although you can
also drag and use a mouse wheel). Upper-right is a control to let you switch
layers on and off. Bottom-left is a scale bar, and bottom right are your mouse
coordinates and a bookmarkable `permalink' - this lets you zoom and shift your map,
and then get a web link you can use to preserve the state of the map.

\section*{John Snow cholera data}

This is a famous data set from the 1854 map of cholera cases in London. The data 
used here come from the \texttt{snow\_files.zip} downloaded from the web site for
the book Applied Spatial Data Analysis with R by Bivand, Pebesma, and G\'{o}mez-Rubio,
\texttt{http://asdar-book.org/}.

The data come as four shapefile sets - the building outlines, death locations, the
location of the suspected Broad Street pump, and the locations of other water pumps
in the area. We can read these in using \texttt{readOGR} from \texttt{rgdal}, and 
approximate the plot on page 107:

<<fig=TRUE>>=
require(rgdal)
buildings = readOGR("./JohnSnow","buildings")
deaths = readOGR("./JohnSnow","deaths",verbose=FALSE)
pumps = readOGR("./JohnSnow","nb_pump",verbose=FALSE)
brdst = readOGR("./JohnSnow","b_pump",verbose=FALSE)
plot(buildings)
points(deaths,cex=sqrt(deaths@data$Num_Cases/2),
       col="#000000",bg="#808080",pch=21)
points(pumps,pch=8,lwd=3,cex=1)
points(brdst,pch=4,lwd=8,cex=1.5)
@ 

But this lacks context - we want to see these points on a modern map of London. The
first thing we need to do is project the data to the WGS84 coordinate system used
by web mapping packages.

Although the shapefiles have coordinate systems set in their \texttt{.prj}
files, these seem to be slightly wrong, so the first thing we do is give them the
correct projection string from the EPSG database distributed with the \texttt{sp} package:

<<>>=
bng = CRS("+init=epsg:27700") # British Grid
wgs84 = CRS("+init=epsg:4326") # WGS84
proj4string(buildings) = bng
proj4string(deaths) = bng
proj4string(pumps) = bng
proj4string(brdst) = bng
buildings = spTransform(buildings, wgs84)
deaths = spTransform(deaths,wgs84)
pumps = spTransform(pumps,wgs84)
brdst = spTransform(brdst,wgs84)
@ 

 At this point the datasets are all correctly converted to WGS84, so we
 can create a web map with our data layers on.
 
<<>>=
osmMap(list(buildings=buildings, deaths=deaths,
            broadst=brdst, pumps=pumps),
       colours = c("white","grey","blue","blue"),
       outputDir="./SnowMap")
@ 

Looking at that file in our web browser gives us the overlay map:

\includegraphics{screen0.png}

The buildings are obscuring a lot of the detail here so we want to make them
slightly transparent. Edit the \texttt{index.html} file. Find where
the \texttt{buildings} layer is created and add a \texttt{fillOpacity} section to 
change its style definition:
\begin{verbatim}
 var buildings = new OpenLayers.Layer.GML("buildings","buildings.gml",{
        projection: new OpenLayers.Projection("EPSG:4326"),
        style: {
"strokeWidth": 1,
"strokeColor": "#000000",
"fillColor": "#FFFFFF",
"pointRadius": 6,
"fillOpacity": 0.2
          }
       });
\end{verbatim}

Save this and reload the page in your browser. The buildings should now be transparent.

\includegraphics{screen1.png}

OpenLayers allows all sorts of configuration of map style. By using a 
graphic icon and some functions we can scale the points of deaths according
to the number of deaths at each point:

\begin{verbatim}
var context = {
  "getRadius":function(feature){
      return(5+3*Math.sqrt(feature.attributes.Num_Cases));
    }
};

var template = {pointRadius: "${getRadius}", externalGraphic: "skull.png"};
var style = new OpenLayers.Style(template,{context: context});

var deaths = new OpenLayers.Layer.GML("deaths","deaths.gml",{
  projection: new OpenLayers.Projection("EPSG:4326"),
  styleMap: new OpenLayers.StyleMap(style)
 });

map.addLayer(deaths);
\end{verbatim}

\includegraphics{fancymap.png}

\end{document}

